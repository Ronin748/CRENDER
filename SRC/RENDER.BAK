#include "SRC\RENDER.H"

unsigned vstart = VSTART;

int redraw = 0;
int itime = 0;
char vmode = 0;

int pg = 0;

int wireframe = 0;
int faceculling = 1;
int zsort = 1;

void interrupt getTime()
{
	itime += 1;
	redraw = 1;
}

unsigned now() {
	return (unsigned)time(NULL);
}

void r_waitRetrace()
{
	while (inportb(0x3da) & 8); // wait around
	while (!(inportb(0x3da) & 8));
}

void r_flipDouble(BYTE *fb)
{
	memcpy(VSTART, fb, W*H);
}

void r_init()
{
	char p;
	p = pg;

	asm {
		mov ah, 0x0f
		int 0x10
		mov vmode, al // get current video mode

		mov ah, 0
		mov bh, p
		mov al, 0x13 // set 13
		int 0x10

		mov ah, 0x48
		mov bx, 0x10 // 64k
		int 0x21
	}
}

void r_exit()
{
	asm {
		mov ah, 0
		mov bh, 0
		mov bx, 0
		mov al, vmode // return original video mode
		int 0x10
	}
}

void r_flip()
{
	char p;
	p = pg;

	asm {
		mov ah, 05h
		mov al, p
		int 10h
	}
}

void r_drawpixel(int x, int y, BYTE c)
{
	asm {
		mov ax, vstart
		mov es, ax

		mov dx, y
		mov ax, W
		imul dx
		add ax, x

		mov di, ax

		mov dl, c
		mov [es:di], dl
	}
}

void r_swap()
{
	asm {
		mov ax, 0xa0a0
		mov bx, 0xd0a0
		mov es, ax
		mov ds, bx
		mov di, 0
		mov dl, 2
	}
	draw:
	asm {
		mov dl, [ds:di]
		mov [es:di], dl
		add di, 1
		cmp di, 0xf960
		jb draw
	}
}

void r_drawrect(int x, int y, int w, int h, BYTE c)
{
	h += y;
	w += x;

	x = clamp(x, L, R);
	y = clamp(y, L, R);
	w = clamp(w, L, R);
	h = clamp(h, L, R);

	if (w <= x || h <= y) {
		return;
	}

	h *= W;
	y *= W;

	asm {
		push bp
		mov ax, vstart
		mov es, ax

		mov dl, c

		mov si, x
		mov ax, si
		mov bx, y
		mov cx, w
		mov bp, h
	}
	draw:
	asm {
		mov di, ax
		add di, bx
		mov [es:di], dl
		inc ax
		cmp ax, cx
		jb draw
		add bx, W
		mov ax, si
		cmp bx, bp
		jb draw
	}
	asm pop bp
}

// line draw, pretty slow, implement in asm
void r_drawline(float (*v0)[2], float (*v1)[2], BYTE c)
{
	int x;
	int y;
	int vx0;
	int vy0;
	int vx1;
	int vy1;
	float dx;
	float dy;
	float k;
	int i;
	int s;
	float kx;
	float ky;
	float diff;

	if ((*v0)[1] < (*v1)[1]) {
		vx0 = (*v0)[0];
		vy0 = (*v0)[1];
		vx1 = (*v1)[0];
		vy1 = (*v1)[1];
	}
	else {
		vx1 = (*v0)[0];
		vy1 = (*v0)[1];
		vx0 = (*v1)[0];
		vy0 = (*v1)[1];
	}

	dx = vx1 - vx0;
	dy = vy1 - vy0;

	k = dy/dx;

	if (fabs(k) <= 1) {
		s = sign(dx);
		ky = k;
		kx = 1.0f;
		diff = fabs(dx);
	}
	else {
		s = sign(dy);
		kx = 1.0f/k;
		ky = 1.0f;
		diff = fabs(dy);
	}

	for (i = 0; i <= diff; i += 1) {
		x = vx0 + (float)i*s*kx;
		y = vy0 + (float)i*s*ky;

		if (y > B)
			return;
		if (y < T)
			continue;
		if (x > R)
			continue;
		if (x < L)
			continue;

		if (x < L)
			x = L;
		if (x > R)
			x = R;

		y *= W;
		x += y;

		asm {
			mov ax, vstart
			mov es, ax
			mov di, x
			mov dl, c
			mov [es:di], dl
		}
	}
}

void r_drawlinef(float x0, float y0, float x1, float y1, BYTE c)
{
	float v0[2];
	float v1[2];

	v0[0] = x0;
	v0[1] = y0;

	v1[0] = x1;
	v1[1] = y1;

	r_drawline(&v0, &v1, c);
}

// horizontal line draw with x sort, usually fast
void r_drawlineh(int x0, int x1, int y, BYTE c)
{
	int to;
	if (x0 > x1) {
		to = x0;
		x0 = x1;
		x1 = to;
	}

	asm {
		mov ax, vstart
		mov es, ax

		mov dx, y
		mov ax, W
		imul dx

		mov bx, x1
		mov di, x0
		add bx, ax
		add di, ax

		mov dl, c
	}
	draw:
	asm {
		mov [es:di], dl
		inc di
		cmp di, bx
		jb draw
	}
}

void r_halftrifill(float x0, float x1, int y,
										int dy, float k0, float k1,
										BYTE c)
{
	int i, xi0, xi1;
	for (i = 0; i < dy; ++i) {
		x0 += k0;
		x1 += k1;
		y += 1;

		if (y > B)
			return;
		if (y < T)
			continue;
		if (x0 > R)
			continue;
		if (x1 < L)
			continue;

		xi0 = round(x0);
		xi1 = round(x1);

		if (x0 < L)
			xi0 = L;
		if (x1 > R)
			xi1 = R;

		asm {
			mov ax, vstart
			mov es, ax

			mov dx, y
			mov ax, W
			imul dx

			mov si, xi1
			mov di, xi0
			add si, ax
			add di, ax

			mov dl, c
		}
		drawt:
		asm {
			mov [es:di], dl
			add di, 1
			cmp di, si
			jbe drawt
		}
	}
}

/*
	Asm triangle fill using integers
	no clipping, but higher precision
*/
void r_nchalftrifill(float x0, float x1, int y,
										int dy, float k0, float k1,
										BYTE c)
{
	unsigned xi0, xi1, ki0, ki1, ye;
	unsigned err = 40; // correction

	xi0 = (unsigned)(x0*128.0f);
	xi1 = (unsigned)(x1*128.0f);
	ki0 = (unsigned)(k0*128.0f);
	ki1 = (unsigned)(k1*128.0f);

	if (dy <= 0)
		return;

	ye = y + dy;

	y *= W;
	ye *= W;

	asm {
		mov ax, vstart // video memory start
		mov es, ax

		mov bx, xi0 // initial points
		add bx, err
		mov cx, xi1
		mov dx, y
	}
	drawt:
	asm {
		add bx, ki0 // x0 += k0
		add cx, ki1 // x1 += k1
		add dx, W // y += 1
	}
	asm {
		mov di, bx
		sub di, err // correction
		shr di, 7 // divide by 128

		mov si, cx
		add si, err
		shr si, 7
	}
	asm {
		add si, dx // calculate final addresses
		add di, dx

		mov al, c // color
	}
	drawl: // line draw
	asm {
		mov [es:di], al // write to screen
		add di, 1
		cmp di, si
		jb drawl // x < x1?

		mov ax, ye
		cmp dx, ax
		jb drawt // lines left?
	}
}

/*
 * triangle draw coordinate system
 * same as opengl with origin [0.0f, 0.0f]
 * screen range [-1.0f, 1.0f], [-1.0f, 1.0f]
*/
void r_drawtri(float v[3][2], BYTE c)
{
	float to;
	int xl0;
	int xl1;
	int yl;

	float k0;
	float k1;
	float k2;

	float dx1;
	float dx2;

	float dy1;
	float dy2;

	// transform from gl to pix
	float x0 = (v[0][0]+1.0f)*W*0.5f;
	float y0 = (-v[0][1]+1.0f)*H*0.5f;

	float x1 = (v[1][0]+1.0f)*W*0.5f;
	float y1 = (-v[1][1]+1.0f)*H*0.5f;

	float x2 = (v[2][0]+1.0f)*W*0.5f;
	float y2 = (-v[2][1]+1.0f)*H*0.5f;

	// sort vertices by y
	if (y0 > y2) {
		to = y0;
		y0 = y2;
		y2 = to;
		to = x0;
		x0 = x2;
		x2 = to;
	}
	if (y1 > y2) {
		to = y1;
		y1 = y2;
		y2 = to;
		to = x1;
		x1 = x2;
		x2 = to;
	}
	if (y0 > y1) {
		to = y0;
		y0 = y1;
		y1 = to;
		to = x0;
		x0 = x1;
		x1 = to;
	}

	x0 = round(x0);
	x1 = round(x1);
	x2 = round(x2);

	y0 = round(y0);
	y1 = round(y1);
	y2 = round(y2);

	// bounds
	if (x0 > R && x1 > R && x2 > R)
		return;
	if (x0 < L && x1 < L && x2 < L)
		return;
	if (y0 > B && y1 > B && y2 > B)
		return;
	if (y0 < T && y1 < T && y2 < T)
		return;

	if (wireframe) {
		r_drawlinef(x0, y0, x1, y1, c);
		r_drawlinef(x1, y1, x2, y2, c);
		r_drawlinef(x0, y0, x2, y2, c);

		return;
	}

	// first - last
	dx1 = (x2 - x0);
	dy1 = (y2 - y0);
	k0 = (dx1/dy1);

	// first - mid
	dx1 = (x1 - x0);
	dy1 = (y1 - y0);
	k1 = (dx1/dy1);

	// mid - last
	dx2 = (x2 - x1);
	dy2 = (y2 - y1);
	k2 = (dx2/dy2);

	x1 = x0; // sort x
	to = k0;
	if (k0 > k1) {
		k0 = k1;
		k1 = to;
	}

	// top
	r_nchalftrifill(x0, x1, (int) y0, (int) dy1 - 1, k0, k1, c);

	k0 = to;
	if (k0 < k2) {
			to = k0;
			k0 = k2;
			k2 = to;
	}
	dy2 += 1.0f;
	y2 = y2 - dy2;
	x1 = x2 - k0*(dy2);
	x2 = x2 - k2*(dy2);

	// bottom
	r_nchalftrifill(x1, x2, (int) y2, (int) dy2 - 1, k0, k2, c);
}


void r_drawtri3d(vec4* v0, vec4* v1, vec4* v2, BYTE c)
{
	float t[3][2];

	float z0 = v0->z;
	float z1 = v1->z;
	float z2 = v2->z;

	if (z0 <= ZNEAR || z1 <= ZNEAR || z2 <= ZNEAR)
		return;

	if (z0 >= ZFAR && z1 >= ZFAR && z2 >= ZFAR)
		return;

	// projection
	t[0][0] = v0->x;
	t[0][0] /= z0;
	t[0][1] = v0->y;
	t[0][1] /= z0;

	t[1][0] = v1->x;
	t[1][0] /= z1;
	t[1][1] = v1->y;
	t[1][1] /= z1;

	t[2][0] = v2->x;
	t[2][0] /= z2;
	t[2][1] = v2->y;
	t[2][1] /= z2;

	r_drawtri(t, c);
}

void r_fill()
{
	asm {
		mov ax, 0xa000
		mov es, ax
		mov dl, 2
		mov di, 0xfa00
	}
	draw:
	asm {
		sub di, 1
		mov [es:di], dl
		cmp di, 0
		ja draw
	}
}

void r_clear()
{
	asm {
		mov ax, 0xa0a0
		mov es, ax
		xor di, di
		mov cx, 0xf960
		mov ax, 0
		rep stosw
	}
}

void r_scr()
{
	asm {
		mov ah, 0x6
		xor al, al
		mov bh, 0x3
		mov cx, 0x0100
		mov dx, 0x182a
		int 10h
	}
}

