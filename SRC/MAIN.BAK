#include "SRC\RENDER.H"

unsigned char keycode = 0;
unsigned char keycodeBuffer[256];
unsigned char keycodeTail = 0;

void matpr(struct mat4* m)
{
	printf("%.1f %.1f %.1f %.1f \n", m->m[0][0], m->m[0][1], m->m[0][2], m->m[0][3]);
	printf("%.1f %.1f %.1f %.1f \n", m->m[1][0], m->m[1][1], m->m[1][2], m->m[1][3]);
	printf("%.1f %.1f %.1f %.1f \n", m->m[2][0], m->m[2][1], m->m[2][2], m->m[2][3]);
	printf("%.1f %.1f %.1f %.1f \n", m->m[3][0], m->m[3][1], m->m[3][2], m->m[3][3]);
}

void vecpr(struct vec4* v)
{
	printf("%.1f %.1f %.1f %.1f \n", v->x, v->y, v->z, v->w);
}

void interrupt (*oldkb) ();

void interrupt (*oldtime) ();

void interrupt getKeys()
{
	// get code from keyboard
	asm cli

	asm {
		in al, 0x060	// read code
		mov keycode, al
		in al, 0x061	// status
		mov bl, al
		or al, 0x080
		out 0x061, al
		mov al, bl
		out 0x061, al

		mov al, 0x020	// reset
		out 0x020, al

		sti
	}

	*(keycodeBuffer + keycodeTail) = keycode;

	++keycodeTail;
}

char* getBitStr(BYTE b)
{
	int i;
	BYTE o;
	unsigned int s = sizeof(BYTE) * 8; // in bits
	char* bits = malloc(s); // not freed

	for (i = 0; i < s; ++i) {
		o = b << i; // shift to high
		o >>= s - 1; // shift to low, fills w zeroes

		i[bits] = (o ? 1 : 0) + 48; // calculate char code
	}

	return bits; // bits left hanging around
}

void waitRetrace()
{
	while (inportb(0x3da) & 8); // wait around
	while (!(inportb(0x3da) & 8));
	r_clear();
	//r_scr();
}

int main()
{
	unsigned i;

	long int t;
	int running;
	unsigned lt;
	unsigned nt;

	unsigned frames;
	unsigned fps;

	float posx;
	float posy;
	float posz;

	float rotx;
	float roty;

	int key;
	int keydown[256];

	float dt;
	float rt;
	int rs;

	float walk_spd;

	float vt[3][2] = {{50.0f, 50.0f}, {300.0f, 100.0f}, {200.0f, 180.0f}};

	// projection matrix
	struct mat4 pm = projmat(PI*0.5f, 320.0f/200.0f, 100.0f, 0.1f);
	// camera matrix
	struct mat4 cm = mat4(1.0);

	struct vec4 v0 = vec4(0.0f, 2.0f, 0.0f, 1.0f);
	struct vec4 v1 = vec4(-1.0f, 0.0f, 1.0f, 1.0f);
	struct vec4 v2 = vec4(1.0f, 0.0f, 1.0f, 1.0f);

	struct vec4 u0 = vec4(0.0f, 2.0f, 0.0f, 1.0f);
	struct vec4 u1 = vec4(-1.0f, 0.0f, 1.0f, 1.0f);
	struct vec4 u2 = vec4(0.0f, 0.0f, -1.4f, 1.0f);

	struct vec4 w0 = vec4(0.0f, 2.0f, 0.0f, 1.0f);
	struct vec4 w1 = vec4(1.0f, 0.0f, 1.0f, 1.0f);
	struct vec4 w2 = vec4(0.0f, 0.0f, -1.4f, 1.0f);

	struct vec4 t0 = vec4(0.0f, 1.0f, 2.0f, 1.0f);
	struct vec4 t1 = vec4(1.0f, 0.0f, 2.0f, 1.0f);
	struct vec4 t2 = vec4(0.0f, 0.0f, 2.0f, 1.0f);

	// camera position
	struct vec4 cam;

	t = 0;
	running = 1;
	lt = 0;
	nt = 0;

	frames = 1000;
	fps = 1000;

	posx = 0.0f;
	posy = 0.0f;
	posz = -4.0f;

	roty = 0.0f;
	rotx = 0.0f;

	key = 0;

	dt = 1.0f;
	rt = 1.0f;
	rs = 0;

	r_init();

	oldkb = getvect(9);
	setvect(9, getKeys); // hook up kb

	oldtime = getvect(0x1c);
	setvect(0x1c, getTime);

	while (running) {
		++t;
		++frames;

		waitRetrace();
		//r_clear();

		rs -= itime;

		cam = vec4(-posx, -posy, -posz, 0.0f);

		rm = mat4(1.0f);

		rm = rotateX(&cm, rotx);

		rm = rotateY(&rm, roty);

		rm = translate(&rm, cam);

		rm = rotateY(&rm, t*0.01f);

		//matpr(&rm);

		r_add(&v0, &v1, &v2, 2);

		r_add(&u0, &u1, &u2, 3);

		r_add(&w0, &w1, &w2, 4);

		r_sort();

		r_draw();

		//r_drawtri3d(&t0, &t1, &t2, 5);

		rs += itime;

		nt = itime;
		if (nt - lt >= 16) { // runs every second
			rt = ((rs/16.0f)/(float)frames)*1000.0f*0.25f + rt*0.75f;
			rs = 0;
			lt = nt;
			fps = frames;
			frames = 0;
			dt = 60.0f/((float)fps);
		}

		printf("fps: %u, key: %i, rt: %.1f  \r",
		 fps, keycode, rt);

		//getKeys();

		for (i = 0; i < 256; ++i) {
			key = keycodeBuffer[i];
			keycodeBuffer[i] = 0;

			if (key == 1) {
				running = 0; // halt program
			}

			// key press and release
			if (key == 17) {
				keydown[(int)'w'] = 1;
			}
			if (key == 145) {
				keydown[(int)'w'] = 0;
			}
			if (key == 30) {
				keydown[(int)'a'] = 1;
			}
			if (key == 158) {
				keydown[(int)'a'] = 0;
			}
			if (key == 31) {
				keydown[(int)'s'] = 1;
			}
			if (key == 159) {
				keydown[(int)'s'] = 0;
			}
			if (key == 32) {
				keydown[(int)'d'] = 1;
			}
			if (key == 160) {
				keydown[(int)'d'] = 0;
			}
			if (key == 77) {
				keydown[(int)'0'] = 1; // right
			}
			if (key == 205) {
				keydown[(int)'0'] = 0;
			}
			if (key == 75) {
				keydown[(int)'1'] = 1; // left
			}
			if (key == 203) {
				keydown[(int)'1'] = 0;
			}
			if (key == 72) {
				keydown[(int)'2'] = 1; // up
			}
			if (key == 200) {
				keydown[(int)'2'] = 0;
			}
			if (key == 80) {
				keydown[(int)'3'] = 1; // down
			}
			if (key == 208) {
				keydown[(int)'3'] = 0;
			}
			if (key == 19) {
				keydown[(int)'r'] = 1;
			}
			if (key == 147) {
				keydown[(int)'r'] = 0;
			}
			if (key == 33) {
				keydown[(int)'f'] = 1;
			}
			if (key == 161) {
				keydown[(int)'f'] = 0;
			}
		}

		walk_spd = 0.04f;

		// game input
		if (keydown[(int)'w']) {
			posz += cos(roty)*walk_spd*dt;
			posx += -sin(roty)*walk_spd*dt;
		}
		if (keydown[(int)'a']) {
			posx -= cos(roty)*walk_spd*dt;
			posz -= sin(roty)*walk_spd*dt;
		}
		if (keydown[(int)'s']) {
			posz -= cos(roty)*walk_spd*dt;
			posx -= -sin(roty)*walk_spd*dt;
		}
		if (keydown[(int)'d']) {
			posx += cos(roty)*walk_spd*dt;
			posz += sin(roty)*walk_spd*dt;
		}
		if (keydown[(int)'0']) {
			roty -= 0.02f*dt;
		}
		if (keydown[(int)'1']) {
			roty += 0.02f*dt;
		}
		if (keydown[(int)'2']) {
			rotx += 0.02f*dt;
		}
		if (keydown[(int)'3']) {
			rotx -= 0.02f*dt;
		}
		if (keydown[(int)'r']) {
			posy += 0.04f*dt;
		}
		if (keydown[(int)'f']) {
			posy -= 0.04f*dt;
		}
	}

	r_exit();

	setvect(9, oldkb);
	setvect(0x1c, oldtime);

	return 0;
}
